{"pages":[],"posts":[{"title":"mockjs常用配置","text":"​ 在进行前后端分离式的开发中，前端负责制作页面和显示数据，后端负责提供数据，前端通过后端提供的RESTFul规范的接口来获取 JSON 格式的数据： ​ 对于前端开发人员来说，必须要从服务器获取数据，所以就只能等待后端开发好接口之后，前端才可以获取数据，这会影响前端开发的效果。 ​ 聪明的前端开发人员就会想：如果前端可以自己模拟出数据，那么在开发时就不需要服务器提供的数据了。于是就出现了mockjs。 快速入门下载可以使用 npm 下载 mockjs： 1npm install mockjs 该命令会把 mockjs 下载到 node_modules 目录中，页面中引入即可使用： 1&lt;script src=&quot;node_modules/mockjs/dist/mock-min.js&quot;&gt;&lt;/script&gt; 模拟数据模拟一个用户列表，用户三个字段组件：自增ID、姓名、年龄 应用到项目中​ 在项目中，我们可以在执行AJAX之前，使用Mock为接口模拟数据，当执行AJAX时会匹配相应URL的模拟数据： 模拟数据设置迟延时间​ 我们可以使用 Mock.setup 来设置模拟数据时的延迟时间，单位：毫秒。可以设置一个固定的时间，也可以使用-设置一个时间段： 12345678// 延迟4秒Mock.setup({ timeout: 4000})// 延迟3~9秒Mock.setup({ timeout: '3000-9000'}) 模拟数据可以使用 Mock.mock 生成模拟数据。 直接生成模拟数据 1Mock.mock(模板|function) 为接口地址模拟数据 1Mock.mock(url,模板|function) 为接口以及请求方式模拟数据 1Mock.mock(url,type,模板|function) 说明：url也可以是一个字符串也可以是一个正则。 模板语法模拟数据时要根据模板来模拟，模板是一个对象类型的值，格式为： 1'名称|规则':'值' 名称：模拟的数据的名字。值：模拟的数据的值。规则：模拟出数据的规则，常用的几个规则： min-max：生成的范围 count：生成的数量 +step：递增step 如果值是一个数组，规则代表数组中元素的个数： 如果希望生成的ID自增可以使用+1 生成随机数据​ 我们一般在模拟数据时都希望生成一些随机的数据，mock中内置了很多种不同类型的随机数据，我们可以使用它们生成各种类型的随机数据： Type Method 基本类型 boolean, natural, integer, float, character, string, range, date, time, datetime, now 图片 image, dataImage 颜色 color 文本 paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle 姓名 first, last, name, cfirst, clast, cname 网站 url, domain, email, ip, tld 地址 area, region 编号 guid, id 使用时我们只需要把值设置成 @方法名 即可，比如，生成一个随机的 Email： #生成boolean @boolean 生成数字自然数(&gt;=0整数)@natural@natural(min,max) 整数@integer@integer(min,max) 小数@float@float(min,max,dmin,dmax) dmin：小数部分位数最小值 dmax：小数部分位数最大值 整数整组@range(min,max)@range(min,max,step) step：递增的步长 12345678@range(10)// =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]@range(3, 7)// =&gt; [3, 4, 5, 6]@range(1, 10, 2)// =&gt; [1, 3, 5, 7, 9]@range(1, 10, 3)// =&gt; [1, 4, 7] 生成文本单个字符@character@character(‘lower/upper/number/symbol’)@character(pool) ​ 如果传入了 'lower' 或 'upper'、'number'、'symbol'，表示从内置的字符池中选取一个字符： 123456{ lower: &quot;abcdefghijklmnopqrstuvwxyz&quot;, upper: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;, number: &quot;0123456789&quot;, symbol: &quot;!@#$%^&amp;*()[]&quot;} 字符串@string@string(length)@string(min,max) 英文单词@word@word(length)@word(min,max) 英文句子@sentence@sentence(len)@sentence(min,max) 英文段落@paragraph@paragraph(len)@paragraph(min,max) 中文汉字@cword@cword(pool)@cword(len)@cword(pool,len)@cword(min,max)@cword(pool,min,max) 123456789101112@cword()// =&gt; &quot;干&quot;@cword('零一二三四五六七八九十')// =&gt; &quot;六&quot;@cword(3)// =&gt; &quot;别金提&quot;@cword('零一二三四五六七八九十', 3)// =&gt; &quot;&quot;七七七&quot;&quot;@cword(5, 7)// =&gt; &quot;设过证全争听&quot;@cword('零一二三四五六七八九十', 5, 7)// =&gt; &quot;九七七零四&quot; 中文句子@csentence@csentence(len)@csentence(min,max) 中文段落@cparagraph@cparagraph(len)@cparagraph(min,max) 中文标题@ctitle@ctitle(len)@ctitle(min,max) 生成名字英文名@first 名@last 姓@name 姓名@name(middle) middle：是否生成中间名字 1234@name()// =&gt; &quot;Larry Wilson&quot;@name(true)// =&gt; &quot;Helen Carol Martinez&quot; 中文名@cfirst 姓@clast 名@cname 姓名 12@cname()// =&gt; &quot;袁军&quot; 网站生成一个IP@ip 生成一个Email@email@email(domain) domain：指定域名 1234@email()// =&gt; &quot;x.davis@jackson.edu&quot;@email('nuysoft.com')// =&gt; &quot;h.pqpneix@nuysoft.com&quot; 生成域名@domain 生成URL@url@url(protocol,host) protocol：指定协议，例如HTTP host：指定域名 123456@url()// =&gt; &quot;mid://axmg.bg/bhyq&quot;@url('http')// =&gt; &quot;http://splap.yu/qxzkyoubp&quot;@url('http', 'nuysoft.com')// =&gt; &quot;http://nuysoft.com/ewacecjhe&quot; 生成时间基本用法@date@time@datetime 格式化时间可以通过 format 参数设置时间的格式 @date(format)@time(format)@datetime(format) Format Description Example yyyy A full numeric representation of a year, 4 digits 1999 or 2003 yy A two digit representation of a year 99 or 03 y A two digit representation of a year 99 or 03 MM Numeric representation of a month, with leading zeros 01 to 12 M Numeric representation of a month, without leading zeros 1 to 12 dd Day of the month, 2 digits with leading zeros 01 to 31 d Day of the month without leading zeros 1 to 31 HH 24-hour format of an hour with leading zeros 00 to 23 H 24-hour format of an hour without leading zeros 0 to 23 hh 12-hour format of an hour without leading zeros 1 to 12 h 12-hour format of an hour with leading zeros 01 to 12 mm Minutes, with leading zeros 00 to 59 m Minutes, without leading zeros 0 to 59 ss Seconds, with leading zeros 00 to 59 s Seconds, without leading zeros 0 to 59 SS Milliseconds, with leading zeros 000 to 999 S Milliseconds, without leading zeros 0 to 999 A Uppercase Ante meridiem and Post meridiem AM or PM a Lowercase Ante meridiem and Post meridiem am or pm T Milliseconds, since 1970-1-1 00:00:00 UTC 759883437303 生成地址生成中国大区@region 12@region()// =&gt; &quot;华北&quot; 生成省份@province 生成城市@city@city(prefix) prefix：布尔值，是否生成所属的省 1234@city()// =&gt; &quot;唐山市&quot;@city(true)// =&gt; &quot;福建省 漳州市&quot; 生成县@county@county(prefix) prefix：布尔值，是否生成所属省、市 1234@county()// =&gt; &quot;上杭县&quot;@county(true)// =&gt; &quot;甘肃省 白银市 会宁县&quot; 生成邮政编码@zip 编号身份证@id 12@id()// =&gt; &quot;420000200710091854&quot; GUID@guid 12@guid()// =&gt; &quot;662C63B4-FD43-66F4-3328-C54E3FF0D56E&quot; 生成图片图片URL（需要联网）@image()@image( size )@image( size, background )@image( size, background, text )@image( size, background, foreground, text )@image( size, background, foreground, format, text ) size：尺寸，格式为：’宽x高’ background：背景色，格式为：#FFFFFF text：图片上显示的文本 foreground：广本颜色 format：图片格式，可选值包括：png、gif、jpg。 123456789101112@image()// =&gt; &quot;http://dummyimage.com/125x125&quot;@image('200x100')// =&gt; &quot;http://dummyimage.com/200x100&quot;@image('200x100', '#fb0a2a')// =&gt; &quot;http://dummyimage.com/200x100/fb0a2a&quot;@image('200x100', '#02adea', 'Hello')// =&gt; &quot;http://dummyimage.com/200x100/02adea&amp;text=Hello&quot;@image('200x100', '#00405d', '#FFF', 'Mock.js')// =&gt; &quot;http://dummyimage.com/200x100/00405d/FFF&amp;text=Mock.js&quot;@image('200x100', '#ffcc33', '#FFF', 'png', '!')// =&gt; &quot;http://dummyimage.com/200x100/ffcc33/FFF.png&amp;text=!&quot; Base64图片编码（不需要联网）@dataImage@dataImage(size)@dataImage(size,text) 生成颜色@color@hex@rgb@rgba@hsl","link":"/LF210-LF210.github.io/2021/06/09/mockjs%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"几种常用的排序算法","text":"冒泡排序12345678910function bubbleSort(arr) { for (let i = 0; i &lt; arr.length - 1; i++) { for (let j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] } } } return arr} 选择排序12345678910111213function selectSort(arr) { let index for (let i = 0; i &lt; arr.length; i++) { index = i for (let j = i + 1; j &lt; arr.length; j++) { if (arr[j] &lt; arr[index]) { index = j } } [arr[i], arr[index]] = [arr[index], arr[i]] } return arr} 插入排序12345678910111213function insertSort(arr) { let current, prevIndex for (let i = 1; i &lt; arr.length; i++) { current = arr[i] prevIndex = i - 1 while (prevIndex &gt;= 0 &amp;&amp; arr[prevIndex] &gt; current) { arr[prevIndex + 1] = arr[prevIndex] prevIndex-- } arr[prevIndex + 1] = current } return arr} 希尔排序1234567891011121314151617function shellSort(arr) { let current, prevIndex let gap = parseInt(arr.length / 2) while (gap &gt; 0) { for (let i = gap; i &lt; arr.length; i++) { current = arr[i] prevIndex = i - gap while (prevIndex &gt;= 0 &amp;&amp; arr[prevIndex] &gt; current) { arr[prevIndex + gap] = arr[prevIndex] prevIndex -= gap } arr[prevIndex + gap] = current } gap = parseInt(gap / 2) } return arr} 归并排序123456789101112131415161718function mergeSort(arr) { if (arr.length === 1) return arr let midIndex = parseInt(arr.length / 2) let leftArr = arr.slice(0, midIndex) let rightArr = arr.slice(midIndex) return merge(mergeSort(leftArr), mergeSort(rightArr))}function merge(leftArr, rightArr) { let newArr = [] while (leftArr.length &amp;&amp; rightArr.length) { if (leftArr[0] &gt; rightArr[0]) { newArr.push(rightArr.shift()) } else { newArr.push(leftArr.shift()) } } return newArr.concat(leftArr, rightArr)} 计数排序12345678910111213141516171819function countSort(arr) { let maxNum = Math.max(...arr) let newArr = new Array(maxNum) for (let i = 0; i &lt; arr.length; i++) { if (newArr[arr[i]] == null) { newArr[arr[i]] = 1 } else { newArr[arr[i]]++ } } arr.length = 0 for (let i = 0; i &lt; newArr.length; i++) { while (newArr[i] &gt; 0) { arr.push(i) newArr[i]-- } } return arr} 基数排序123456789101112131415161718192021function radixSort(arr) { let newArr = new Array(10) let max = Math.max(...arr).toString().length let num = 10 for (let i = 0; i &lt; max; i++, num *= 10) { for (let j = 0; j &lt; arr.length; j++) { let index = parseInt((arr[j] % num) / (num / 10)) if (newArr[index] == undefined) { newArr[index] = [] } newArr[index].push(arr[j]) } arr.length = 0 for (let a = 0; a &lt; newArr.length; a++) { while (newArr[a] != undefined &amp;&amp; newArr[a].length &gt; 0) { arr.push(newArr[a].shift()) } } } return arr}","link":"/LF210-LF210.github.io/2021/06/13/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"nginx常用配置","text":"12345678nginx -h 查看帮助信息nginx -v 查看Nginx的版本号nginx -V 显示Nginx的版本号和编译信息start nginx 启动Nginxnginx -s stop 快速停止和关闭Nginxnginx -s quit 正常停止或关闭Nginxnginx -s reload 配置文件修改重新加载nginx -t 测试Nginx配置文件的正确性及配置文件的详细信息","link":"/LF210-LF210.github.io/2021/06/10/nginx%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"数据结构","text":"队列12345678910111213141516171819202122232425262728293031323334353637class Queue { constructor() { this.dataScore = [] } add(element) { this.dataScore.push(element) } remove() { return this.dataScore.shift() } front() { return this.dataScore[0] } back() { return this.dataScore[this.dataScore.length - 1] } clear() { this.dataScore = [] } empty() { return this.dataScore.length == 0 } toString() { let str = '' for (let value of this.dataScore) { str += value + '\\n' } return str.substring(0, str.length - 1) }} 栈123456789101112131415161718class Stack { constructor() { this.dataScore = [] this.top = 0 } add(element) { this.dataScore[this.top++] = element } pop() { return this.dataScore[--this.top] } peek() { return this.dataScore[this.top - 1] }} 单向链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 节点类class Node { constructor(data, next = null) { this.data = data this.next = next }}// 单向链表类class LinkList { constructor() { this.head = new Node('head') this.length = 0 } add(element) { let lastNode = this.findLast() lastNode.next = new Node(element) this.length++ } findLast() { let node = this.head while (node.next !== null) { node = node.next } return node } toString() { let node = this.head while (node.next !== null) { node = node.next console.log(node.data) } console.log('length: ' + this.length) } find(element) { let node = this.head while (node.next !== null) { node = node.next if (node.data === element) { return node } } return null } findPrev(element) { let node = this.head while (node.next !== null &amp;&amp; node.next.data !== element) { if (node.next == null) { return null } node = node.next } return node } remove(element) { let prevNode = this.findPrev(element) if (prevNode) { prevNode.next = prevNode.next.next this.length-- return true } else { return false } } insert(element, newElement) { let node = this.find(element) if (node) { let newNode = new Node(newElement) newNode.next = node.next node.next = newNode this.length++ return true } return false }} 哈希表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class HashTable { constructor(limit = 11) { this.limit = limit this.dataScore = new Array(limit) this.count = 0 this.num = 7 } getHashCode(key) { let hashCode = 0 for (let i = 0; i &lt; key.length; i++) { hashCode = hashCode * this.num + key[i].charCodeAt() } return hashCode % this.limit } put(key, value) { let index = this.getHashCode(key) let bucket = this.dataScore[index] if (!bucket) { bucket = this.dataScore[index] = [] } for (let i = 0; i &lt; bucket.length; i++) { if (bucket[i][0] === key) { bucket[i][1] = value return true } } bucket.push([key, value]) this.count++ if (this.count / this.limit &gt; 0.75) { this.resize(this.getPrime(this.limit * 2)) } } get(key) { let index = this.getHashCode(key) let bucket = this.dataScore[index] if (!bucket) { return null } for (let i = 0; i &lt; bucket.length; i++) { if (bucket[i][0] === key) { return bucket[i][1] } } return null } remove(key) { let index = this.getHashCode(key) let bucket = this.dataScore[index] if (!bucket) { return false } for (let i = 0; i &lt; bucket.length; i++) { if (bucket[i][0] === key) { bucket.splice(i, 1) this.count-- if (this.limit &gt; 11 &amp;&amp; this.count / this.limit &lt; 0.25) { this.resize(this.getPrime(Math.floor(this.limit / 2))) } return true } } } resize(newLimit) { let data = this.dataScore this.count = 0 this.dataScore = [] this.limit = newLimit data.forEach(bucket =&gt; { if (bucket) { for (let value of bucket) { this.put(value[0], value[1]) } } }) } isPrime(num) { let temp = Math.ceil(Math.sqrt(num)) for (let i = 2; i &lt; temp; i++) { if (num % i === 0) { return false } } return true } getPrime(num) { while (!this.isPrime(num)) { num++ } return num } size() { return this.count }} 二叉搜索树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193class Node { constructor(data) { this.data = data this.left = null this.right = null }}class BinarySearchTree { constructor() { this.root = null } insert(data) { let newNode = new Node(data) if (this.root === null) { this.root = newNode return } let current = this.root let parent = null while (true) { parent = current if (current.data &gt; data) { current = current.left if (current === null) { parent.left = newNode break } } else { current = current.right if (current === null) { parent.right = newNode break } } } } preOrder() { this.preorderTraversal(this.root) } preorderTraversal(node) { if (node !== null) { this.preorderTraversal(node.left) console.log(node.data) this.preorderTraversal(node.right) } } inOrder() { this.inorderTraversal(this.root) } inorderTraversal(node) { if (node !== null) { console.log(node.data) this.preorderTraversal(node.left) this.preorderTraversal(node.right) } } postOrder() { this.postorderTraversal(this.root) } postorderTraversal(node) { if (node !== null) { this.preorderTraversal(node.left) this.preorderTraversal(node.right) console.log(node.data) } } getMin() { let current = this.root while (current.left !== null) { current = current.left } return current } getMax() { let current = this.root while (current.right !== null) { current = current.right } return current } search(data) { let current = this.root while (current !== null) { if (current.data &gt; data) { current = current.left } else if (current.data &lt; data) { current = current.right } else { return current } } return false } remove(data) { let current = this.root let parent = null let isLeftChild = true while (current.data !== data) { parent = current if (current.data &gt; data) { current = current.left isLeftChild = true } else { isLeftChild = false current = current.right } if (current === null) { return false } } if (current.left === null &amp;&amp; current.right === null) { if (current === this.root) { this.root = null } else if (isLeftChild) { parent.left = null } else { parent.right = null } } else if (current.left === null) { if (current === this.root) { this.root = current.right } else if (isLeftChild) { parent.left = current.right } else { parent.right = current.right } } else if (current.right === null) { if (current === this.root) { this.root = current.left } else if (isLeftChild) { parent.left = current.left } else { parent.right = current.left } } else { let successor = this.getSuccessor(current) if (current === this.root) { this.root = successor } else if (isLeftChild) { parent.left = successor } else { parent.right = successor } successor.left = current.left } } getSuccessor(node) { let successor = node.right let successorParent = node while (successor.left !== null) { successorParent = successor successor = successor.left } if (successor !== node.right) { successorParent.left = null successor.right = node.right } return successor } getCount() { return this.getNum(this.root) } getNum(node) { if (node === null) { return 0 } return this.getNum(node.left) + this.getNum(node.right) + 1 }}","link":"/LF210-LF210.github.io/2021/06/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"mockjs","slug":"mockjs","link":"/LF210-LF210.github.io/tags/mockjs/"},{"name":"排序算法","slug":"排序算法","link":"/LF210-LF210.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"nginx","slug":"nginx","link":"/LF210-LF210.github.io/tags/nginx/"},{"name":"数据结构","slug":"数据结构","link":"/LF210-LF210.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"前端","slug":"前端","link":"/LF210-LF210.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/LF210-LF210.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"运维","slug":"运维","link":"/LF210-LF210.github.io/categories/%E8%BF%90%E7%BB%B4/"}]}