{"pages":[],"posts":[{"title":"git常用指令","text":"全局设置 git config --global user.name 用户名git config --global user.email 用户邮箱如果语句带参数则是设置，不带参数则为读取 初始化仓库 git init 从远程仓库克隆仓库到本地 git clone 仓库地址 查看当前工作目录和提交状态 git status git 提交修改到暂存区 提交特定文件git add 文件 1 文件 2提交所有存在改动的文件git add . 提交修改到本地仓库 git commit -m 提交信息 提交修改到远程仓库 git push 从远程仓库拉取代码 git pull 切换分支 git switch 分支名 或 git checkout 分支名 新建分支 git checkout -b 分支名 合并分支 git merge 分支名 查看当前分支版本信息 git loggit log --graph (以图形化（节点）展示) 删除分支 git branch -d 分支名git branch -D 分支名 (强制删除) 将本地仓库与远程仓库关联 git remote add origin https://gitee.com/LFB410/demo.gitgit push -u origin master 将分支迁移到某一版本 git reset HEAD^ （迁移到上个版本） HEAD 表示当前版本 HEAD^ 上一个版本 HEAD^^ 上上一个版本 HEAD^^^ 上上上一个版本 以此类推…git reset 哈希值 （迁移到指定的版本）","link":"/LF210-LF210.github.io/2021/06/22/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"title":"js中截取字符串的方法","text":"slice slice() 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。语法：str.slice(开始位置[, 结束位置]) 如果开始位置为负数，则效果等同于 str.length + index 如果省略第二个参数，则会截取到字符串末尾 substr substr()方法返回一个字符串中从指定位置开始到指定字符数的字符。语法：str.substr(开始位置[, 要截取的长度]) 如果开始位置为负数，则效果等同于 str.length + index 警告： 尽管 String.prototype.substr(…) 没有严格被废弃 (as in “removed from the Web standards”), 但它被认作是遗留的函数并且可以的话应该避免使用。它并非 JavaScript 核心语言的一部分，未来将可能会被移除掉。如果可以的话，使用 substring() 替代它 - MDN substring substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。语法：str.substring(开始位置[, 结束位置]) 如果两个参数都是正数，substring() 方法会选择两个参数中较小的作为起始位置，较大的作为结束位置，str.substring(0, 3)的效果和 str.substring(3, 0)是一样的 如果没有结束位置，则会截取到字符串末尾 如果任一参数小于 0 或为 NaN，则被视为 0 相同点： 如果只有一个参数，那么这三个方法的效果都是相同的","link":"/LF210-LF210.github.io/2021/06/15/js%E4%B8%AD%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"mockjs常用配置","text":"​ 在进行前后端分离式的开发中，前端负责制作页面和显示数据，后端负责提供数据，前端通过后端提供的RESTFul规范的接口来获取 JSON 格式的数据： ​ 对于前端开发人员来说，必须要从服务器获取数据，所以就只能等待后端开发好接口之后，前端才可以获取数据，这会影响前端开发的效果。 ​ 聪明的前端开发人员就会想：如果前端可以自己模拟出数据，那么在开发时就不需要服务器提供的数据了。于是就出现了mockjs。 快速入门下载可以使用 npm 下载 mockjs： 1npm install mockjs 该命令会把 mockjs 下载到 node_modules 目录中，页面中引入即可使用： 1&lt;script src=&quot;node_modules/mockjs/dist/mock-min.js&quot;&gt;&lt;/script&gt; 附：mockjs在线文档 http://mockjs.com/examples.html模拟数据模拟一个用户列表，用户三个字段组件：自增ID、姓名、年龄 应用到项目中​ 在项目中，我们可以在执行AJAX之前，使用Mock为接口模拟数据，当执行AJAX时会匹配相应URL的模拟数据： 模拟数据设置迟延时间​ 我们可以使用 Mock.setup 来设置模拟数据时的延迟时间，单位：毫秒。可以设置一个固定的时间，也可以使用-设置一个时间段： 12345678// 延迟4秒Mock.setup({ timeout: 4000})// 延迟3~9秒Mock.setup({ timeout: '3000-9000'}) 模拟数据可以使用 Mock.mock 生成模拟数据。 直接生成模拟数据 1Mock.mock(模板|function) 为接口地址模拟数据 1Mock.mock(url,模板|function) 为接口以及请求方式模拟数据 1Mock.mock(url,type,模板|function) 说明：url也可以是一个字符串也可以是一个正则。 模板语法模拟数据时要根据模板来模拟，模板是一个对象类型的值，格式为： 1'名称|规则':'值' 名称：模拟的数据的名字。值：模拟的数据的值。规则：模拟出数据的规则，常用的几个规则： min-max：生成的范围 count：生成的数量 +step：递增step 如果值是一个数组，规则代表数组中元素的个数： 如果希望生成的ID自增可以使用+1 生成随机数据​ 我们一般在模拟数据时都希望生成一些随机的数据，mock中内置了很多种不同类型的随机数据，我们可以使用它们生成各种类型的随机数据： Type Method 基本类型 boolean, natural, integer, float, character, string, range, date, time, datetime, now 图片 image, dataImage 颜色 color 文本 paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle 姓名 first, last, name, cfirst, clast, cname 网站 url, domain, email, ip, tld 地址 area, region 编号 guid, id 使用时我们只需要把值设置成 @方法名 即可，比如，生成一个随机的 Email： #生成boolean @boolean 生成数字自然数(&gt;=0整数)@natural@natural(min,max) 整数@integer@integer(min,max) 小数@float@float(min,max,dmin,dmax) dmin：小数部分位数最小值 dmax：小数部分位数最大值 整数整组@range(min,max)@range(min,max,step) step：递增的步长 12345678@range(10)// =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]@range(3, 7)// =&gt; [3, 4, 5, 6]@range(1, 10, 2)// =&gt; [1, 3, 5, 7, 9]@range(1, 10, 3)// =&gt; [1, 4, 7] 生成文本单个字符@character@character(‘lower/upper/number/symbol’)@character(pool) ​ 如果传入了 'lower' 或 'upper'、'number'、'symbol'，表示从内置的字符池中选取一个字符： 123456{ lower: &quot;abcdefghijklmnopqrstuvwxyz&quot;, upper: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;, number: &quot;0123456789&quot;, symbol: &quot;!@#$%^&amp;*()[]&quot;} 字符串@string@string(length)@string(min,max) 英文单词@word@word(length)@word(min,max) 英文句子@sentence@sentence(len)@sentence(min,max) 英文段落@paragraph@paragraph(len)@paragraph(min,max) 中文汉字@cword@cword(pool)@cword(len)@cword(pool,len)@cword(min,max)@cword(pool,min,max) 123456789101112@cword()// =&gt; &quot;干&quot;@cword('零一二三四五六七八九十')// =&gt; &quot;六&quot;@cword(3)// =&gt; &quot;别金提&quot;@cword('零一二三四五六七八九十', 3)// =&gt; &quot;&quot;七七七&quot;&quot;@cword(5, 7)// =&gt; &quot;设过证全争听&quot;@cword('零一二三四五六七八九十', 5, 7)// =&gt; &quot;九七七零四&quot; 中文句子@csentence@csentence(len)@csentence(min,max) 中文段落@cparagraph@cparagraph(len)@cparagraph(min,max) 中文标题@ctitle@ctitle(len)@ctitle(min,max) 生成名字英文名@first 名@last 姓@name 姓名@name(middle) middle：是否生成中间名字 1234@name()// =&gt; &quot;Larry Wilson&quot;@name(true)// =&gt; &quot;Helen Carol Martinez&quot; 中文名@cfirst 姓@clast 名@cname 姓名 12@cname()// =&gt; &quot;袁军&quot; 网站生成一个IP@ip 生成一个Email@email@email(domain) domain：指定域名 1234@email()// =&gt; &quot;x.davis@jackson.edu&quot;@email('nuysoft.com')// =&gt; &quot;h.pqpneix@nuysoft.com&quot; 生成域名@domain 生成URL@url@url(protocol,host) protocol：指定协议，例如HTTP host：指定域名 123456@url()// =&gt; &quot;mid://axmg.bg/bhyq&quot;@url('http')// =&gt; &quot;http://splap.yu/qxzkyoubp&quot;@url('http', 'nuysoft.com')// =&gt; &quot;http://nuysoft.com/ewacecjhe&quot; 生成时间基本用法@date@time@datetime 格式化时间可以通过 format 参数设置时间的格式 @date(format)@time(format)@datetime(format) Format Description Example yyyy A full numeric representation of a year, 4 digits 1999 or 2003 yy A two digit representation of a year 99 or 03 y A two digit representation of a year 99 or 03 MM Numeric representation of a month, with leading zeros 01 to 12 M Numeric representation of a month, without leading zeros 1 to 12 dd Day of the month, 2 digits with leading zeros 01 to 31 d Day of the month without leading zeros 1 to 31 HH 24-hour format of an hour with leading zeros 00 to 23 H 24-hour format of an hour without leading zeros 0 to 23 hh 12-hour format of an hour without leading zeros 1 to 12 h 12-hour format of an hour with leading zeros 01 to 12 mm Minutes, with leading zeros 00 to 59 m Minutes, without leading zeros 0 to 59 ss Seconds, with leading zeros 00 to 59 s Seconds, without leading zeros 0 to 59 SS Milliseconds, with leading zeros 000 to 999 S Milliseconds, without leading zeros 0 to 999 A Uppercase Ante meridiem and Post meridiem AM or PM a Lowercase Ante meridiem and Post meridiem am or pm T Milliseconds, since 1970-1-1 00:00:00 UTC 759883437303 生成地址生成中国大区@region 12@region()// =&gt; &quot;华北&quot; 生成省份@province 生成城市@city@city(prefix) prefix：布尔值，是否生成所属的省 1234@city()// =&gt; &quot;唐山市&quot;@city(true)// =&gt; &quot;福建省 漳州市&quot; 生成县@county@county(prefix) prefix：布尔值，是否生成所属省、市 1234@county()// =&gt; &quot;上杭县&quot;@county(true)// =&gt; &quot;甘肃省 白银市 会宁县&quot; 生成邮政编码@zip 编号身份证@id 12@id()// =&gt; &quot;420000200710091854&quot; GUID@guid 12@guid()// =&gt; &quot;662C63B4-FD43-66F4-3328-C54E3FF0D56E&quot; 生成图片图片URL（需要联网）@image()@image( size )@image( size, background )@image( size, background, text )@image( size, background, foreground, text )@image( size, background, foreground, format, text ) size：尺寸，格式为：’宽x高’ background：背景色，格式为：#FFFFFF text：图片上显示的文本 foreground：广本颜色 format：图片格式，可选值包括：png、gif、jpg。 123456789101112@image()// =&gt; &quot;http://dummyimage.com/125x125&quot;@image('200x100')// =&gt; &quot;http://dummyimage.com/200x100&quot;@image('200x100', '#fb0a2a')// =&gt; &quot;http://dummyimage.com/200x100/fb0a2a&quot;@image('200x100', '#02adea', 'Hello')// =&gt; &quot;http://dummyimage.com/200x100/02adea&amp;text=Hello&quot;@image('200x100', '#00405d', '#FFF', 'Mock.js')// =&gt; &quot;http://dummyimage.com/200x100/00405d/FFF&amp;text=Mock.js&quot;@image('200x100', '#ffcc33', '#FFF', 'png', '!')// =&gt; &quot;http://dummyimage.com/200x100/ffcc33/FFF.png&amp;text=!&quot; Base64图片编码（不需要联网）@dataImage@dataImage(size)@dataImage(size,text) 生成颜色@color@hex@rgb@rgba@hsl","link":"/LF210-LF210.github.io/2021/06/09/mockjs%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"mysql基础知识点","text":"mysql 服务 启动服务net start mysql 停止服务net stop mysql 创建/添加 创建数据库create database 数据库名; 创建表(创建表时至少要有一个字段)create table 表名(字段名 字段类型 [字段属性])[字符集]; 添加字段(默认添加到最后)alter table 表名 add 新字段名 字段类型 [字段属性] [位置(first/after 字段名)]; 添加数据insert into 表名 [字段名] values (数据); 批量添加数据insert into 表名 [字段名] values(数据 1),(数据 2)…; 删除 删除数据库drop database 数据库名; 删除表drop table 表名; 批量删除表drop table 表名 1,表名 2…; 删除字段alter table 表名 drop 字段名; 删除数据delete 字段名 from 表名 [where 条件]; 限制删除数据的数量delete 字段名 from 表名 [where 条件] limit 限制的数量; 删除所有数据并重置自动增长 auto_increment 的值truncate 表名 修改 修改表名rename table 旧表名 to 新表名; 修改字段alter table 表名 change 旧字段名 新字段名 字段类型 [字段属性]; 修改字段类型alter table 表名 modify 字段名 字段类型 [字段属性]; 修改数据update 表名 set 字段 = 新值 [where 条件]; 限制修改数据的数量update 表名 set 字段 = 新值 [where 条件] limit 限制的数量; 修改客户端所有字符集set names 字符集; 查询 查询所有数据库show databases; 按条件查询数据库show databases like 条件(xx%以 xx 开头,%xx 以 xx 结尾,xx_yy 以 xx 开头且以 yy 结尾); 查询数据库创建语句show create database 数据库名 查询所有表show tables; 按条件查询表show tables like 条件(xx%以 xx 开头,%xx 以 xx 结尾,xx_yy 以 xx 开头且以 yy 结尾); 查询表创建语句show create table 表名; 查询表结构desc 表名; 查询数据select 字段名 from 表名; 根据条件查询数据select 字段名 from 表名 where 字段名 = 值; 字段类型 整数类型tinyint(迷你整形，用 1 个字节保存的整形，最大能表示的数是 0-255)smallint(小整形，用 2 个字节保存的整形，最大能表示的数是 0-65535)mediumint(中整形，用 3 个字节保存的整形)int(整形，用 4 个字节保存的整形)bigint(大整型，用 8 个字节保存的整形) 浮点型(可能损失精度)float(单精度类型小数)double(双精度类型小数) 定点型(能保证精度)decimal(定点型) 时间类型date(日期类型 YYYY-mm-dd)time(时间类型 HH:ii:ss)datatime(日期时间类型 YYYY-mm-dd HH:ii:ss)timestamp(时间戳类型 YYYY-mm-dd HH:ii:ss)year(年类型 YYYY) 字符串类型char(定长字符)varchar(变长字符) 文本类型text(存储普通的文本类型)blob(存储二进制的文本类型) 枚举类型enum(枚举类型,可以规范数据本身,限定只能插入规定的数据,并且可以节省存储空间) 集合类型set(集合类型) 字段属性(null，默认值，烈描述，主键，唯一键，自动增长) null 属性，代表字段能否为空 默认为 yes(字段默认能为空) 用法：设置 not null 时字段不能为空 默认值 default，规定字段的默认值default 的默认值为 null如果在插入数据时为空,则数据变为默认值用法：default 默认值 列描述comment 是给开发人员的注释用法：comment 注释 主键primary key 是保证字段值的唯一性的键，一张表中只能有一个主键用法 1：随表创建(直接在需要设置主键的字段名后面添加 primary key)用法 2：随表创建(在所有字段之后添加 primary key(字段名))用法 3：表后添加(alter 表名 add primary key(字段名))删除主键：alter table 表名 drop primary key主键约束：1.(主键所在的字段对应的数据不能为空) 2.(主键所在字段对应的数据不能有任何重复) 唯一键unique key 是保证字段值唯一性的键，一张表中能有多个唯一键unique key 允许所在字段对应的数据为 null，null 可以有多个(null 不参与比较)用法 1：随表创建(直接在需要设置主键的字段名后面添加 unique [key])用法 2：随表创建(之间在所有字段之后添加 unique key(字段名))用法 3：表后添加(alter 表名 add unique key(字段名))删除唯一键：alter table 表名 drop index(唯一键所在的字段名)唯一键作用：在数据不为空的情况下,不允许重复 自动增长auto_increment 当给字段设置自动增长之后，当改字段的数据为空时，系统根据之前存在的数据进行自动添加(只适用于数值)一张表中只能存在一个自动增长的字段,且该字段必须设置为主键或唯一键用法 1：随表创建(直接在需要设置自动增长的字段名后面添加 auto-increment)修改自动增长：alter table 表名 auto_increment = 值(只能改大不能改的比原有数字小)删除自动增长方法 1：alter table 表名 change 自动增长所在的字段名 自动增长所在的字段名 原有字段类型;删除自动增长方法 2：alter table 表名 modify 自动增长所在的字段名 原有字段类型 外键用于表间关系的一一对应用法：随表创建(在创建表最后使用：foreign key(外键名) references 对应的主键的表名(对应表中的主键字段)) 表间关系 一对一一张表中的一条记录与另外一张表中最多有一条明确的关系，通常设计保证两张表中使用同样的主键即可常见用处：将一张表拆分，常用的字段放一张表，不常用的字段放另一张表 一对多在多关系的表中对应一个表的一个字段，这个字段也是一关系的主键 多对多一张表的一条记录在另一张表中能匹配到多条记录，反之亦然 主键冲突在插入数据时，有时会出现主键重复的冲突解决方法 1：insert into 表名 [字段名] values(值) on duplicate key update 字段 = 新值;解决方法 2：replace into 表名 [字段名] values(值);如果插入数据时出现主键重复的冲突则会删除原来的数据，再将新的数据插入 蠕虫复制从已有的数据中获取数据，成倍复制后插入到表中用法：insert into 表名[字段名] select */字段名 from 表名意义：可以快速增加表中的数据量，主要用于测试表的压力 高级查询select [select 选项] 字段列表 from 数据 [where 条件] group by 分组 having 条件 order by 排序 limit 限制数字; select 选项(系统应如何处理查询到的结果) all(默认)：表示保存所有的记录 distinct：去除重复的记录，只保留一条 字段列表(由单个或多个字段名组成，全部字段用*表示) 将查询出的字段名修改为别名：字段名 [as] 别名 from 数据 单表数据：from 表名 多表数据：from 表名 1,表名 2,…(会出现笛卡尔积,避免使用) 动态数据：select * from (select 字段名 from 表名) as 别名 where 条件用于在从数据库中拿数据的时候进行条件筛选 group by 数据分组单分组用法：group by 字段名(根据字段名进行分类)group by 一般与聚合函数组合使用： count()统计每组中的数量，如果统计目标是字段则不统计 null，如果为*则统计每条记录 avg()求目标字段平均值 max()求目标字段的最大值 min()求目标字段的最小值 sum()求和group_concat()字符串拼接，可以将字符串拼接到一起多分组用法：group by 字段名 1,字段名 2字段排序：1.升序(默认)：group asc 2. 降序：group desc回溯统计：当分组进行多分组之后，往上统计的过程中，需要进行层层上报，将这种层层上报统计的过程称之为回溯统计用法：group by 字段[asc/desc] with rollup; having 数据筛选用法：having 条件(与 where 用法类似)where 与 having 的区别：where 不能用聚合函数和函数别名，having 则可以使用 order by 数据排序用法：order by 字段 [asc/desc] limit 限制记录数量用法：limit 限制的数量分页用法：limit 获取的索引,获取的数据量 算术运算符(+ - * / %) 除法的运算结果是以浮点数表示的 除法中如果除数为 0,结果为 null 对 null 进行任何算术运算结果都为 null 比较运算符(&gt; &gt;= &lt; &lt;= = &lt;&gt;) 数据会先转换为同类型再进行比较(字符串和数字) 代表 false 1 代表 true 条件区间 between 条件 1 and 条件 2(条件 1 必须小于等于条件 2，否则会查找不到数据，如果条件 1 与条件 2 值相等即为查找那个值) 逻辑运算符(and,or,not) and 逻辑与 表示既要…又要…单个 and 跟 between 作用相同 or 逻辑或 表示要么…要么… not 逻辑非 表示否定 in 运算符用于替代= 当结果不是单个值 而是一个集合(很多值)的时候使用例如：select * from 表名 where id in(‘值 1’,’值 2’…) is 运算符is 用于判断数据是否为 null用法：is null/is not null like 运算符like 用于模糊匹配用法:like 匹配模式(_匹配对应的单个结果,%用于匹配对应的多个结果) 联合查询联合查询可以合并多个类似的选择查询的结果集(不同的表的字段数量必须相同，字段名以第一个表中的字段为准)用法：select 语句 union[union 选项] select 语句union 选项：1. all(显示全部数据无论是否重复，默认值) 2. distinct(显示去重后的数据)如果在联合查询中使用 order by 那么对应的 select 语句必须用括号括起来，语句后必须加 limit 限制语句 连接查询连接查询是将多张表连到一起进行查询的查询法(会导致记录数行和字段数列发生改变) 交叉连接：将一张表的数据与另一张表的数据进行交叉(会产生笛卡尔积，实际作用不大)用法 1：select _ from 表 1 cross join 表 2;用法 2：select _ from 表 1,表 2; 内连接：从一张表中取出所有的数据去另一张表中匹配，符合匹配条件则保留，不符合条件则放弃用法：select * from 表 1 inner join 表 2 on 匹配条件(表 1.字段名 = 表 2.字段名)如果内连接没有条件，结果就会与交叉连接一样(笛卡尔积)内连接可以不加 on 条件,因此可以在数据匹配完成后使用 where 进行条件限制，效果用 on 一样(最好用 on) 外连接：以一张表作为主表，根据条件去匹配另一张表，从而得到目标数据外连接分为 1. left join 左连接(主表在左侧) 2. right join 右连接(主表在右侧)原理：拿主表的每一条数据与从表的每一条数据根据条件进行匹配，从表中数据满足条件保留，不满足条件则显示为 null(主表中字段一定会保留)左连接用法：select _ from 表 1(主表) left join 表 2(从表) on 条件右连接用法：select _ from 表 1(从表) right join 表 2(主表) on 条件 using 关键字using 关键字用于在连接查询中代替 on 进行条件匹配的使用 using 关键字的前提是对应的两张表连接的字段是同名的如果使用 using 关键字，对应的同名字段在结果中只会保留一个用法：select * from 表 1 [inner,left,right]join 表 2 using(同名字段列表);","link":"/LF210-LF210.github.io/2021/06/13/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"nginx常用配置","text":"12345678nginx -h 查看帮助信息nginx -v 查看Nginx的版本号nginx -V 显示Nginx的版本号和编译信息start nginx 启动Nginxnginx -s stop 快速停止和关闭Nginxnginx -s quit 正常停止或关闭Nginxnginx -s reload 配置文件修改重新加载nginx -t 测试Nginx配置文件的正确性及配置文件的详细信息","link":"/LF210-LF210.github.io/2021/06/10/nginx%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"nodejs操作excel表格","text":"准备工作：node-xlsx 包 读取 excel 表格 12345const xlsx = require('node-xlsx')// 读取文件const sheetList = xlsx.parse('文件路径')// 读取bufferconst sheetListBuffer = xlsx.parse(fs.readFileSync('文件路径')) node-xlsx 中 excel 的数据格式 123456789101112131415161718// 读取出来的数据格式如下[ { name: 'Sheet1', data: [ ['姓名', '年龄', '手机号', '住址'], ['LF', 21, '138238xxxxx', '广东省'] ] }, { name: 'Sheet2', data: [ ['日期', '收益'], ['2021/6/17', -500], ['2021/6/18', 250] ] }] 写入数据 1234567891011121314// 写入的数据格式需与读取时的数据格式一致const data = { name: 'mySheetName', data: [ [1, 2, 3], [true, false, null, 'sheetjs'], ['foo', 'bar', new Date('2014-02-19T14:30Z'), '0.3'], ['baz', null, 'qux'] ]}var buffer = xlsx.build([data])fs.writeFile('../demo.xlsx', buffer, () =&gt; { console.log('创建excel表格成功')}) 官方文档：https://www.npmjs.com/package/node-xlsx","link":"/LF210-LF210.github.io/2021/06/16/nodejs%E6%93%8D%E4%BD%9Cexcel%E8%A1%A8%E6%A0%BC/"},{"title":"几种常用的排序算法","text":"冒泡排序12345678910function bubbleSort(arr) { for (let i = 0; i &lt; arr.length - 1; i++) { for (let j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] } } } return arr} 选择排序12345678910111213function selectSort(arr) { let index for (let i = 0; i &lt; arr.length; i++) { index = i for (let j = i + 1; j &lt; arr.length; j++) { if (arr[j] &lt; arr[index]) { index = j } } [arr[i], arr[index]] = [arr[index], arr[i]] } return arr} 插入排序12345678910111213function insertSort(arr) { let current, prevIndex for (let i = 1; i &lt; arr.length; i++) { current = arr[i] prevIndex = i - 1 while (prevIndex &gt;= 0 &amp;&amp; arr[prevIndex] &gt; current) { arr[prevIndex + 1] = arr[prevIndex] prevIndex-- } arr[prevIndex + 1] = current } return arr} 希尔排序1234567891011121314151617function shellSort(arr) { let current, prevIndex let gap = parseInt(arr.length / 2) while (gap &gt; 0) { for (let i = gap; i &lt; arr.length; i++) { current = arr[i] prevIndex = i - gap while (prevIndex &gt;= 0 &amp;&amp; arr[prevIndex] &gt; current) { arr[prevIndex + gap] = arr[prevIndex] prevIndex -= gap } arr[prevIndex + gap] = current } gap = parseInt(gap / 2) } return arr} 归并排序123456789101112131415161718function mergeSort(arr) { if (arr.length === 1) return arr let midIndex = parseInt(arr.length / 2) let leftArr = arr.slice(0, midIndex) let rightArr = arr.slice(midIndex) return merge(mergeSort(leftArr), mergeSort(rightArr))}function merge(leftArr, rightArr) { let newArr = [] while (leftArr.length &amp;&amp; rightArr.length) { if (leftArr[0] &gt; rightArr[0]) { newArr.push(rightArr.shift()) } else { newArr.push(leftArr.shift()) } } return newArr.concat(leftArr, rightArr)} 计数排序12345678910111213141516171819function countSort(arr) { let maxNum = Math.max(...arr) let newArr = new Array(maxNum) for (let i = 0; i &lt; arr.length; i++) { if (newArr[arr[i]] == null) { newArr[arr[i]] = 1 } else { newArr[arr[i]]++ } } arr.length = 0 for (let i = 0; i &lt; newArr.length; i++) { while (newArr[i] &gt; 0) { arr.push(i) newArr[i]-- } } return arr} 基数排序123456789101112131415161718192021function radixSort(arr) { let newArr = new Array(10) let max = Math.max(...arr).toString().length let num = 10 for (let i = 0; i &lt; max; i++, num *= 10) { for (let j = 0; j &lt; arr.length; j++) { let index = parseInt((arr[j] % num) / (num / 10)) if (newArr[index] == undefined) { newArr[index] = [] } newArr[index].push(arr[j]) } arr.length = 0 for (let a = 0; a &lt; newArr.length; a++) { while (newArr[a] != undefined &amp;&amp; newArr[a].length &gt; 0) { arr.push(newArr[a].shift()) } } } return arr}","link":"/LF210-LF210.github.io/2021/06/13/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"数据结构","text":"队列 12345678910111213141516171819202122232425262728293031323334353637class Queue { constructor() { this.dataScore = [] } add(element) { this.dataScore.push(element) } remove() { return this.dataScore.shift() } front() { return this.dataScore[0] } back() { return this.dataScore[this.dataScore.length - 1] } clear() { this.dataScore = [] } empty() { return this.dataScore.length == 0 } toString() { let str = '' for (let value of this.dataScore) { str += value + '\\n' } return str.substring(0, str.length - 1) }} 栈123456789101112131415161718class Stack { constructor() { this.dataScore = [] this.top = 0 } add(element) { this.dataScore[this.top++] = element } pop() { return this.dataScore[--this.top] } peek() { return this.dataScore[this.top - 1] }} 单向链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 节点类class Node { constructor(data, next = null) { this.data = data this.next = next }}// 单向链表类class LinkList { constructor() { this.head = new Node('head') this.length = 0 } add(element) { let lastNode = this.findLast() lastNode.next = new Node(element) this.length++ } findLast() { let node = this.head while (node.next !== null) { node = node.next } return node } toString() { let node = this.head while (node.next !== null) { node = node.next console.log(node.data) } console.log('length: ' + this.length) } find(element) { let node = this.head while (node.next !== null) { node = node.next if (node.data === element) { return node } } return null } findPrev(element) { let node = this.head while (node.next !== null &amp;&amp; node.next.data !== element) { if (node.next == null) { return null } node = node.next } return node } remove(element) { let prevNode = this.findPrev(element) if (prevNode) { prevNode.next = prevNode.next.next this.length-- return true } else { return false } } insert(element, newElement) { let node = this.find(element) if (node) { let newNode = new Node(newElement) newNode.next = node.next node.next = newNode this.length++ return true } return false }} 哈希表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class HashTable { constructor(limit = 11) { this.limit = limit this.dataScore = new Array(limit) this.count = 0 this.num = 7 } getHashCode(key) { let hashCode = 0 for (let i = 0; i &lt; key.length; i++) { hashCode = hashCode * this.num + key[i].charCodeAt() } return hashCode % this.limit } put(key, value) { let index = this.getHashCode(key) let bucket = this.dataScore[index] if (!bucket) { bucket = this.dataScore[index] = [] } for (let i = 0; i &lt; bucket.length; i++) { if (bucket[i][0] === key) { bucket[i][1] = value return true } } bucket.push([key, value]) this.count++ if (this.count / this.limit &gt; 0.75) { this.resize(this.getPrime(this.limit * 2)) } } get(key) { let index = this.getHashCode(key) let bucket = this.dataScore[index] if (!bucket) { return null } for (let i = 0; i &lt; bucket.length; i++) { if (bucket[i][0] === key) { return bucket[i][1] } } return null } remove(key) { let index = this.getHashCode(key) let bucket = this.dataScore[index] if (!bucket) { return false } for (let i = 0; i &lt; bucket.length; i++) { if (bucket[i][0] === key) { bucket.splice(i, 1) this.count-- if (this.limit &gt; 11 &amp;&amp; this.count / this.limit &lt; 0.25) { this.resize(this.getPrime(Math.floor(this.limit / 2))) } return true } } } resize(newLimit) { let data = this.dataScore this.count = 0 this.dataScore = [] this.limit = newLimit data.forEach(bucket =&gt; { if (bucket) { for (let value of bucket) { this.put(value[0], value[1]) } } }) } isPrime(num) { let temp = Math.ceil(Math.sqrt(num)) for (let i = 2; i &lt; temp; i++) { if (num % i === 0) { return false } } return true } getPrime(num) { while (!this.isPrime(num)) { num++ } return num } size() { return this.count }} 二叉搜索树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193class Node { constructor(data) { this.data = data this.left = null this.right = null }}class BinarySearchTree { constructor() { this.root = null } insert(data) { let newNode = new Node(data) if (this.root === null) { this.root = newNode return } let current = this.root let parent = null while (true) { parent = current if (current.data &gt; data) { current = current.left if (current === null) { parent.left = newNode break } } else { current = current.right if (current === null) { parent.right = newNode break } } } } preOrder() { this.preorderTraversal(this.root) } preorderTraversal(node) { if (node !== null) { this.preorderTraversal(node.left) console.log(node.data) this.preorderTraversal(node.right) } } inOrder() { this.inorderTraversal(this.root) } inorderTraversal(node) { if (node !== null) { console.log(node.data) this.preorderTraversal(node.left) this.preorderTraversal(node.right) } } postOrder() { this.postorderTraversal(this.root) } postorderTraversal(node) { if (node !== null) { this.preorderTraversal(node.left) this.preorderTraversal(node.right) console.log(node.data) } } getMin() { let current = this.root while (current.left !== null) { current = current.left } return current } getMax() { let current = this.root while (current.right !== null) { current = current.right } return current } search(data) { let current = this.root while (current !== null) { if (current.data &gt; data) { current = current.left } else if (current.data &lt; data) { current = current.right } else { return current } } return false } remove(data) { let current = this.root let parent = null let isLeftChild = true while (current.data !== data) { parent = current if (current.data &gt; data) { current = current.left isLeftChild = true } else { isLeftChild = false current = current.right } if (current === null) { return false } } if (current.left === null &amp;&amp; current.right === null) { if (current === this.root) { this.root = null } else if (isLeftChild) { parent.left = null } else { parent.right = null } } else if (current.left === null) { if (current === this.root) { this.root = current.right } else if (isLeftChild) { parent.left = current.right } else { parent.right = current.right } } else if (current.right === null) { if (current === this.root) { this.root = current.left } else if (isLeftChild) { parent.left = current.left } else { parent.right = current.left } } else { let successor = this.getSuccessor(current) if (current === this.root) { this.root = successor } else if (isLeftChild) { parent.left = successor } else { parent.right = successor } successor.left = current.left } } getSuccessor(node) { let successor = node.right let successorParent = node while (successor.left !== null) { successorParent = successor successor = successor.left } if (successor !== node.right) { successorParent.left = null successor.right = node.right } return successor } getCount() { return this.getNum(this.root) } getNum(node) { if (node === null) { return 0 } return this.getNum(node.left) + this.getNum(node.right) + 1 }}","link":"/LF210-LF210.github.io/2021/06/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"git","slug":"git","link":"/LF210-LF210.github.io/tags/git/"},{"name":"js字符串操作","slug":"js字符串操作","link":"/LF210-LF210.github.io/tags/js%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"name":"mockjs","slug":"mockjs","link":"/LF210-LF210.github.io/tags/mockjs/"},{"name":"mysql","slug":"mysql","link":"/LF210-LF210.github.io/tags/mysql/"},{"name":"nginx","slug":"nginx","link":"/LF210-LF210.github.io/tags/nginx/"},{"name":"nodejs","slug":"nodejs","link":"/LF210-LF210.github.io/tags/nodejs/"},{"name":"排序算法","slug":"排序算法","link":"/LF210-LF210.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/LF210-LF210.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"分支管理","slug":"分支管理","link":"/LF210-LF210.github.io/categories/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"},{"name":"前端","slug":"前端","link":"/LF210-LF210.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"数据库","slug":"数据库","link":"/LF210-LF210.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"运维","slug":"运维","link":"/LF210-LF210.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"后端","slug":"后端","link":"/LF210-LF210.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/LF210-LF210.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}